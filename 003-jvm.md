[Вопросы для собеседования](README.md)

# JVM
+ [Что такое Java?](#Что-такое-Java)
+ [Почему стоить использовать Java?](#Почему-стоить-использовать-Java)
+ [Какие основные отличия в версиях Java?](#Какие-основные-отличия-в-версиях-Java)
+ [Чем различаются JRE, JVM и JDK?](#Чем-различаются-JRE-JVM-и-JDK)
+ [За что отвечает _JVM_?](#За-что-отвечает-JVM)
+ [Расскажите о Classloader](#Расскажите-о-Classloader)
+ [Расскажите о Java Memory Model](#Расскажите-о-Java-Memory-Model)
+ [Расскажите о Run-Time Data Area](#Расскажите-о-Run-Time-Data-Area)
+ [Расскажите о Frames](#Расскажите-о-Frames)
+ [Execution Engine](#Execution-Engine)
+ [Какие существуют Garbage Collectors?](#Какие-существуют-Garbage-Collectors)
+ [Как выполняется профилирование приложений?](#Как-выполняется-профилирование-приложений)
+ [Что такое HeapDump и TreadDump?](#Что-такое-HeapDump-и-TreadDump)
+ [Какие языки (кроме Java) могут быть использованы в разработке ПО, исполняемого в среде JVM?](#Какие-языки-кроме-Java-могут-быть-использованы-в-разработке-ПО-исполняемого-в-среде-JVM)

## Что такое Java?
__Java__ (произноситься как "джава") — строго типизированный объектно-ориентированный язык программирования и одноимённая платформа, разработанные компанией Sun Microsystems (в последующем приобретённой компанией Oracle). Разработка ведётся сообществом, организованным через Java Community Process, язык и основные реализующие его технологии распространяются по лицензии GPL. Права на торговую марку принадлежат корпорации Oracle.

Приложения Java обычно транслируются в специальный байт-код, поэтому они могут работать на любой компьютерной архитектуре, для которой существует реализация JVM (виртуальной Java-машины). Дата официального выпуска — 23 мая 1995 года. На текущий момент один из самых популярных языков программирования и де-факто платформа по умолчанию в разработке ПО уровня предприятия.

Основные области применения: приложения для Android-устройств, веб-сервисы и сайты, промежуточное ПО, микропрограммы для встраиваемых систем. 

[к оглавлению](#jvm)

## Почему стоить использовать Java?
+ Независимость от аппаратной архитектуры.
+ Автоматическое управление памятью.
+ Расширенные возможности обработки исключительных ситуаций.
+ Богатый набор средств фильтрации ввода-вывода.
+ Набор стандартных коллекций: массив, список, стек и т. п.
+ Наличие простых средств создания сетевых приложений (в том числе с использованием протокола RMI).
+ Наличие классов, позволяющих выполнять HTTP-запросы и обрабатывать ответы.
+ Встроенные в язык средства создания многопоточных приложений, которые потом были портированы на многие языки (например Python).
+ Унифицированный доступ к базам данных: 
    + на уровне отдельных SQL-запросов — на основе JDBC, SQLJ;
    + на уровне концепции объектов, обладающих способностью к хранению в базе данных — на основе Java Data Objects (англ.) и Java Persistence API.
+ Поддержка обобщений (начиная с версии 1.5).
+ Поддержка лямбд, замыканий, встроенные возможности функционального программирования (с 1.8)
+ Экосистема содержит громадное количество библиотек, реализующих различные протоколы, подходы и API, как открытые так и проприетарные. 

[к оглавлению](#jvm)

## Какие основные отличия в версиях Java?
### Версия 1.0 - 23 января 1996.

### Версия 1.1 - 19 февраля 1997.
+ __Inner Classes__.
+ __Reflection API__.
+ __JavaBeans__.
+ __JDBC__.
+ __Collections framework__.

### Версия 1.2 - 8 декабря 1998.
+ __`strictfp` keyword__.
+ __JDBC__.

### Версия 1.3 - 8 мая 2000.
+ __HotSpot VM included__.

### Версия 1.4 - 6 февраля 2002.
+ __`assert` keyword__.
+ __NIO.2 library__  - API для работы с неблокирующим вводом-выводом.
+ __Logging API__.

### Версия 5 - 30 сентября 2004 года.
+ __Enum__ - перечислимые типы.
+ __Annotations__ - аннотации, специальные интерфейсы.
+ __Generics__ - средства обобщённого программирования.
+ __Varargs__ - методы с неопределённым числом параметров.
+ __Autoboxing/Unboxing__ — автоматическое преобразование между скалярными типами Java и соответствующими типами-обёртками.
+ __Static import__ - импорт статических полей и методов.
+ __Foreach__ - итератор по коллекции объектов.
+ __Javadoc comments__ - Javadoc-комментариев.

### Версия 6 - 11 декабря 2006 года.
+ __Scripting Language Support__ - общий API для скриптовых языков и встроенный JS-движок Mozilla Rhino. 
+ __JDBC 4.0__.
+ __Java Compiler API__ - возможность программного вызова java-компилятора. 
+ __JAXB 2.0__.
+ __PLuggable Annotations__.
+ __@Override__ - использование аннотации для маркирование методов, реализующих интерфейс или расширяющих родительский класс.

### Версия 7 - 7 июля 2011 года.
+ __InvokeDynamic__ - поддержка динамических языков программирования.
+ __Strings in switch__. - строки в switch-выражениях.
+ __The try-with-resources statement__ - автоматическое управление ресурсами, реализующими интерфейс java.lang.AutoCloseable.
+ __Diamond operator <>__ - улучшенное вычисление типов при создании обобщенных экземпляров.
+ __Simplified varargs method declaration__ - перенос предупреждения "unsafe operation" в место объявление метода с переменным количеством аргументов.
+ __Binary integer literals__ - префикс _0b_ (int i = 0b0101)
+ __Underscores in numeric literals__ - подчеркивания в числах (int i = 1_000)
+ __Catching multiple exception types__ - перехват нескольких типов исключений в одном блоке catch (catch(SQLException | IOException e)).
+ __Concurrency utilities__ - новый синхронизатор Phaser, включён легковесный механизм fork/join.
+ __NIO.2 library__ - добавлены пакеты java.nio.file, java.nio.file.attribute и java.nio.file.spi.

### Версия 8 - 18 марта 2014 года.
+ __Lambda expressions__ - выражения в функциональном стиле.
+ __@FunctionalInterface__ - функциональные интерфейсы.
+ __Stream API__. - возможность выполнения последовательности операций над элементами массива, а также возможность производить их параллельно (parallelStream).
+ __Method Reference__ - ссылки на методы и конструкторы, оператор `::`.
+ __Repeatable annotations__ - возможность использовать аннотации одного типа несколько раз над одним объектом.
+ __Interface default method__ - методы по умолчанию для интерфейсов.
+ __Annotation on Java types__ - аннотации на типы данных.
+ __Reflection for method parameters__ - рефлексия для параметров методов.
+ __Date & Time API (java.time)__.
+ __Remove the PermGen__ - удален _PermGen_, изменен способ хранения мета-данных классов. 

### Версия 9 - 21 сентября 2017 года.

### Версия 10 - 20 марта 2018 года.

### Версия 11 - 25 сентября 2018 года.

### Версия 12 - 19 марта 2019 года.

### Версия 13 - 17 сентября 2019 года.

### Версия 14 - 17 марта 2020 года.

[к оглавлению](#jvm)

## Чем различаются JRE, JVM и JDK?
__JVM__, Java Virtual Machine (Виртуальная машина Java) — основная часть среды времени исполнения Java (JRE). Виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java. JVM может также использоваться для выполнения программ, написанных на других языках программирования.

__JRE__, Java Runtime Environment (Среда времени выполнения Java) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM и стандартного набора библиотек классов Java.

__JDK__, Java Development Kit (Комплект разработки на Java) - JRE и набор инструментов разработчика приложений на языке Java, включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры, документацию, различные утилиты.

Коротко: __JDK__ - среда для разработки программ на Java, включающая в себя __JRE__ - среду для обеспечения запуска Java программ, которая в свою очередь содержит __JVM__ - интерпретатор кода Java программ.

[к оглавлению](#jvm)

## За что отвечает _JVM_?

+ Загрузка, проверка и исполнение байт кода;
+ Предоставление среды выполнения для выполнения байт-кода;
+ Управление памятью и очисткой мусора (Garbage collection);

Виртуальная машина Java (Java Virtual Machine) - это механизм, предоставляющий среду выполнения для управления Java-кодом или приложениями.
Виртуальная машина является независимой оболочкой исполнения кода, благодаря которой возможен её запуск на любой ОС,
без влияния ОС на выполняемую программу. 

JVM работает с 2 типами данных:  примитивные типы (__primitive types__) и ссылочные типы (__reference types__).

__Примитивы__

JVM работает с примитивными значениями (целыми числами и числами с плавающей точкой). По сути, JVM - это 32-битная машина. 
Типы `long` и `double`, которые являются 64-битными, поддерживаются изначально, но занимают две единицы памяти в `frame's local` 
или стеке операндов, поскольку каждая единица составляет 32 бита.
Типы `boolean`, `byte`, `short` и `char` имеют расширенный знак (кроме `char` с нулевым расширением) и работают как 32-разрядные целые числа, так же как и типы `int`.
Меньшие типы имеют только несколько специфических для типа инструкций для загрузки, хранения и преобразования типов.
`boolean` значение работает как 8-битное `byte` значения, где 0 представляет значение __false__, а 1 - значение __true__.

__Типы ссылок и значения__

Существует три типа ссылочных типов: типы классов, типы массивов и типы интерфейсов.
Их значения являются ссылками на динамически создаваемые экземпляры классов, массивы или экземпляры классов или массивы, 
которые реализуют интерфейсы соответственно.

[к оглавлению](#jvm)

## Расскажите о Classloader

Загрузчик классов является частью JRE, которая динамически загружает Java классы в JVM. 
Обычно классы загружаются только по запросу. Система исполнения в Java не должна знать о файлах и файловых системах
благодаря загрузчику классов. __Делегирование является важной концепцией__, которую выполняет загрузчик. Загрузчик классов 
отвечает за поиск библиотек, чтение их содержимого и загрузку классов, содержащихся в библиотеках. 
Эта __загрузка__ обычно выполняется __«по требованию»__, поскольку она не происходит до тех пор, пока программа не вызовет класс.
__Класс с именем может быть загружен только один раз данным загрузчиком классов.__

При запуске JVM, используются три загрузчика классов:
* Bootstrap class loader (Загрузчик класса Bootstrap)
* Extensions class loader (Загрузчик класса расширений)
* System class loader (Системный загрузчик классов)

__Загрузчик класса Bootstrap__ загружает основные библиотеки Java, расположенные в папке `<JAVA_HOME>/jre/lib`. 
Этот загрузчик является частью ядра JVM, написан на нативном коде.

__Загрузчик класса расширений__ загружает код в каталоги расширений 
(`<JAVA_HOME>/jre/lib/ext`, или любой другой каталог, указанный системным свойством `java.ext.dirs`).

__Системный загрузчик__ загружает код, найденный в `java.class.path`, который сопоставляется с переменной среды `CLASSPATH`.
Это реализуется классом `sun.misc.Launcher$AppClassLoader`.

Загрузчик классов выполняет три основных действия в строгом порядке: 
* Загрузка: находит и импортирует двоичные данные для типа. 
* Связывание: выполняет проверку, подготовку и (необязательно) разрешение. 
    - Проверка: обеспечивает правильность импортируемого типа. 
    - Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию. 
    - Разрешение: преобразует символические ссылки из типа в прямые ссылки. 
* Инициализация: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.

__Пользовательский загрузчик классов__

Загрузчик классов написан на Java. Поэтому возможно создать свой собственный загрузчик классов, не понимая тонких деталей JVM.
У каждого загрузчика классов Java есть родительский загрузчик классов, определенный при создании экземпляра нового 
загрузчика классов или в качестве системного загрузчика классов по умолчанию для виртуальной машины.

Что делает возможным следующее:
* загружать или выгружать классы во время выполнения (например, динамически загружать библиотеки во время выполнения, даже из ресурса HTTP).
Это важная особенность для:
    - реализация скриптовых языков;
    - использование bean builders;
    - добавить пользовательскую расширение;
    - позволяя нескольким пространствам имен общаться. Например, это одна из основ протоколов CORBA / RMI;
* изменить способ загрузки байт-кода (например, можно использовать зашифрованный байт-код класса Java);
* модифицировать загруженный байт-код (например, для переплетения аспектов во время загрузки при использовании аспектно-ориентированного программирования);

[к оглавлению](#jvm)

## Расскажите о Java Memory Model
...
[к оглавлению](#jvm)

## Расскажите о Run-Time Data Area

Run-Time Data Areas. JVM выделяет множество областей данных во время выполнения, которые используются во время выполнения программы. Некоторые участки данных
созданы JVM во время старта и уничтожаются во время её выключения. Другие создаются для каждого потока и уничтожаются когда поток уничтожается.

__The pc Register (PCR)__

Виртуальная машина Java может поддерживать много потоков исполнения одновременно. Каждый поток виртуальной машины Java имеет свой собственный регистр PC (programm counter).
В любой момент каждый поток виртуальной машины Java выполняет код одного метода, а именно текущий метод для этого потока.
Если этот метод не является native, регистр pc содержит адрес инструкции виртуальной машины Java, выполняемой в настоящее время.

Коротко говоря: для одного потока существует один PCR, который создается при запуске потока. PCR хранит адрес выполняемой сейчас инструкции JVM.

__Java Virtual Machine Stacks__

Каждый поток в JVM имеет собственный стек, созданный одновременно с потоком.  Стек в JVM хранит frames. 
Стеки в JVM могут иметь фиксированный размер или динамически расширяться и сжиматься в соответствии с требованиями вычислений.

__Heap__

JVM имеет heap (кучу), которая используется всеми потоками виртуальной машины Java. 
Куча - это область данных времени выполнения, из которой выделяется память для всех экземпляров и массивов классов.
Куча создается при запуске виртуальной машины. Хранилище для объектов восстанавливается автоматической системой 
управления данными (известной как сборщик мусора); объекты никогда не освобождаются явно. 
JVM не предполагает какого-либо конкретного типа системы автоматического управления хранением данных, 
и метод управления может быть выбран в соответствии с системными требованиями разработчика. 
Куча может иметь фиксированный размер или может быть расширена в соответствии с требованиями вычислений и может быть сокращена, 
если большая куча становится ненужной. Память для кучи не должна быть смежной.

__Method Area__

JVM имеет область методов, которая является общей для всех потоков. Она хранит структуры для каждого класса, такие как пул констант, данные полей и методов, 
а также код для методов и конструкторов, включая специальные методы, используемые при инициализации классов и экземпляров и инициализации интерфейса.
Хотя область метода является логически частью кучи, простые реализации могут не обрабатываться сборщиком мусора. Область метода может иметь 
фиксированный размер или может быть расширена в соответствии с требованиями вычислений и может быть сокращена, если большая область метода становится ненужной.

__Run-Time Constant Pool__

 A run-time constant pool существует для каждого класса или интерфейса в рантайме и представлено constant_pool таблицей в *.class файле.
 Он содержит несколько видов констант: от числовых литералов, известных во время компиляции, до ссылок на методы и поля, 
 которые должны быть разрешены во время выполнения.  Сам run-time constant pool выполняет функцию,
 аналогичную функции таблицы символов для обычного языка программирования, хотя он содержит более широкий диапазон данных, чем типичная таблица символов.
 Каждый run-time constant pool отделён от JVM's method area. JVM создаёт run-time constant pool вместе с созданием class или interface.
 
__Native Method Stacks__

Реализация виртуальной машины Java может использовать обычные стеки, обычно называемые «стеки Си», для поддержки native methods (методов, написанных на языке, отличном от языка программирования Java).

[к оглавлению](#jvm)

## Расскажите о Frames

Frame используется для хранения данных и частичных результатов, а также для выполнения динамического связывания, возврата значений для методов и отправки исключений.
Новый frame создается каждый раз, когда вызывается метод. Frame уничтожается, когда завершается вызов метода, 
является ли это завершение нормальным или резким (он генерирует неперехваченное исключение). Frames выделяются из стека потока, создающего frame. 
Каждый frame имеет свой собственный массив локальных переменных, свой собственный стек операндов и ссылку на пул констант во время выполнения класса текущего метода.
Размеры массива локальных переменных и стека операндов определяются во время компиляции и предоставляются вместе с кодом для метода, связанного с фреймом.
Таким образом, размер структуры данных frame-а зависит только от реализации виртуальной машины Java, и память для этих структур может быть выделена одновременно при вызове метода.

Только один frame активен в любой точке данного потока управления - метода выполнения, и это frame называется текущим, а его метод известен как текущий метод.
Класс, в котором определен текущий метод, является текущим классом. Операции над локальными переменными и стеком операндов обычно выполняются со ссылкой на текущий frame.

Frame перестает быть текущим, если его метод вызывает другой метод или если его метод завершается. Когда метод вызывается, новый frame создается и становится текущим, 
когда управление переходит к новому методу. При возврате метода текущий frame передает результат вызова метода, если таковой имеется, в предыдущий frame. 
Текущий frame затем отбрасывается, так как предыдущий frame становится текущим. Обратите внимание, что frame, созданный потоком, 
является локальным для этого потока и на него не может ссылаться ни один другой поток.

__Локальные переменные__

Каждый frame содержит массив переменных, известных как его локальные переменные. Длина массива локальных переменных frame определяется во время компиляции 
и предоставляется в двоичном представлении класса или интерфейса вместе с кодом для метода, связанного с frame-ом.
Единичная локальная переменная может хранить значение типа: boolean, byte, char, short, int, float, reference, or returnAddress. 
Пара локальных переменных может хранить значение типов: long или double.

Локальные переменные адресуются путем индексации. Индекс первой локальной переменной равен нулю.

Значение типа long или типа double занимает две последовательные локальные переменные.

JVM использует локальные переменные для передачи параметров при вызове метода. При вызове метода класса все параметры передаются в последовательных локальных переменных, 
начиная с локальной переменной 0. При вызове метода экземпляра локальная переменная 0 всегда используется для передачи ссылки на объект,
для которого вызывается метод экземпляра (this в Java). Любые параметры впоследствии передаются в последовательных локальных переменных, начиная с локальной переменной 1.
 
__Стеки операндов (Operand Stacks)__

Каждый frame содержит стек «последний вошел - первый вышел» (LIFO), известный как стек операндов. Максимальная глубина стека операндов frame-a
определяется во время компиляции и предоставляется вместе с кодом для метода, связанного с frame-ом.

Стек операнда пуст при создании frame-a, который его содержит. JVM предоставляет инструкции для загрузки констант 
или значений из локальных переменных или полей в стек операндов. Другие инструкции JVM берут операнды из стека операндов, 
оперируют с ними и помещают результат обратно в стек операндов. Стек операндов также используется для подготовки параметров 
для передачи в методы и для получения результатов метода.

Для примера, инструкция __iadd__  суммирует два int значения. От стека операндов требуется, чтобы два int значения были наверху стека.
Значения удаляются из стека, операция __pop__. Суммируются и их сумма помещается в стек операндов.

__Динамическое связывание (Dynamic Linking)__

Каждый frame содержит ссылку на  run-time constant pool для типа текущего метода для поддержки динамического связывания кода метода.
Доступ к вызываемым методам и переменным осуществляется через символические ссылки из class файла.
Динамическое связывание преобразует эти символьные ссылки на методы в конкретные ссылки на методы, загружая классы по мере необходимости 
для разрешения пока еще не определенных символов, и преобразует обращения к переменным в соответствующие смещения в структурах хранения, 
связанных с расположением этих переменных во время выполнения.

Позднее связывание методов и переменных вносит изменения в другие классы, которые метод использует с меньшей вероятностью нарушить этот код.

__Нормальное завершение вызова метода__

Вызов метода завершается нормально, если этот вызов не вызывает исключение, либо непосредственно из JVM, либо в результате выполнения явного оператора throw. 
Если вызов текущего метода завершается нормально, то значение может быть возвращено вызывающему методу. 
Это происходит, когда вызванный метод выполняет одну из инструкций возврата, выбор которых должен соответствовать типу возвращаемого значения (если оно есть).

Текущий frame используется в этом случае для восстановления состояния инициатора, включая его локальные переменные и стек операндов, 
с соответствующим образом увеличенным программным счетчиком инициатора, чтобы пропустить инструкцию вызова метода. 
Затем выполнение обычно продолжается в frame вызывающего метода с возвращенным значением (если оно есть), помещаемым в стек операндов этого frame.

__Резкое завершение вызова метода__

Вызов метода завершается преждевременно, если при выполнении инструкции JVM в методе выдает исключение, и это исключение не обрабатывается в методе.
Выполнение команды __athrow__ также приводит к явному выбрасыванию исключения, и если исключение не перехватывается текущим методом, 
приводит к неожиданному завершению вызова метода. Вызов метода, который завершается внезапно, никогда не возвращает значение своему вызывающему.

[к оглавлению](#jvm)

## Execution Engine

Байт-код, назначенный __run-time data areas__, будет выполнен __execution engine__. Механизм выполнения считывает байт-код и выполняет его по частям.

__Interpreter__

Интерпретатор интерпретирует байт-код быстро, но выполняется медленно. Недостаток интерпретатора заключается в том, что когда один метод вызывается несколько раз, каждый раз требуется новая интерпретация.

__JIT Compiler__

JIT-компилятор устраняет недостатки интерпретатора. Механизм выполнения будет использовать помощь интерпретатора при преобразовании байт-кода, 
но когда он находит повторный код, он использует JIT-компилятор, который компилирует весь байт-код и изменяет его на собственный код. 
Этот нативный код будет использоваться непосредственно для повторных вызовов методов, которые улучшают производительность системы.

+ Генератор промежуточного кода (Intermediate Code Generator). Производит промежуточный код.
+ Code Optimizer. Отвечает за оптимизацию промежуточного кода, сгенерированного выше.
+ Генератор целевого кода (Target Code Generator). Отвечает за генерацию машинного кода или родной код.
+ Профилировщик (Profiler). Специальный компонент, отвечающий за поиск горячих точек, то есть, вызывается ли метод несколько раз или нет.

__Garbage Collector__
Garbage Collector ("сборщик мусора") функционирует в фоновом режиме во время работы твоей программы, собирает ставшие ненужными объекты, которые в дальнейшем будут удалены. Таким образом, он освобождает память для создания новых объектов в будущем. На самом деле сборщик мусора не один, а несколько.

[к оглавлению](#jvm)

## Какие существуют Garbage Collectors? 
Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора:

+ __Serial (последовательный)__ — самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. Редко когда используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию.

+ __Parallel (параллельный)__ — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности.

+ __Concurrent Mark Sweep (CMS)__ — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти.

+ __Garbage-First (G1)__ — создан для постепенной замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных.

[к оглавлению](#jvm)

## Как выполняется профилирование приложений?
...

[к оглавлению](#jvm)

## Что такое HeapDump и TreadDump?
...

[к оглавлению](#jvm)

## Какие языки (кроме Java) могут быть использованы в разработке ПО, исполняемого в среде JVM?

_Компилируемые в байт-код Java_:
_Scala_ — объектно-ориентированный и функциональный язык;
_Kotlin_ — объектно-ориентированный язык, используется в том числе для разработки Android-приложений;
_Clojure_ — функциональный язык, диалект Lisp;
_Ceylon_ — объектно-ориентированный язык со строгой статической типизацией.

__Интерпретируемые__:
_Jacl_ - реализация TCL;
_Jython_ — реализация Python;
_JRuby_ — реализация Ruby;
_Groovy_ — сценарный язык;
_Nashorn_ — реализация JavaScript.

[к оглавлению](#jvm)

# Полезные ссылки:
- https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html
- https://www.developer.com/java/data/understanding-the-jvm-architecture.html
- https://dzone.com/articles/understanding-jvm-internals
- https://habr.com/ru/post/269621/

[к оглавлению](#jvm)
